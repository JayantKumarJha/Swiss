# -*- coding: utf-8 -*-
"""1_Ampoule_Scheduler.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EO9RjWIPjr_otDND7ZaBoEITQwng2iNu
"""

import streamlit as st
import pandas as pd
import math
from datetime import datetime, timedelta
from io import BytesIO

st.set_page_config(page_title="Ampoule Scheduler", layout="wide")
st.title("💉 Ampoule Line Scheduler")

uploaded_file = st.file_uploader("Upload Ampoule Excel File", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)

    st.sidebar.header("⚙️ Manual Settings")

    # ✅ Max time override
    MAX_TIME = st.sidebar.number_input("🔧 Max Runtime per Day (mins)", min_value=1, max_value=1440, value=1140)
    CHANGEOVER = 180

    # ✅ Speed override panel
    st.sidebar.subheader("✏️ Speed Override by Pack Size (ml)")
    default_speed_ampoule = {1: 200, 2: 200, 3: 170, 5: 170, 10: 115}
    unique_sizes = sorted(df["Pack Size(ml)"].dropna().unique())
    override_speed = {}

    for size in unique_sizes:
        if isinstance(size, (int, float)):
            default = default_speed_ampoule.get(size, 100)
            override_speed[size] = st.sidebar.number_input(f"{int(size)}ml", 1, 1000, value=default)

    def get_speed(row):
        if not pd.isna(row.get("speed")):
            return row["speed"]
        return override_speed.get(row["Pack Size(ml)"], 100)

    df["Speed"] = df.apply(get_speed, axis=1)
    df["RM Date"] = pd.to_datetime(df["Tentative Arrival Date of RM"])
    df["PM Date"] = pd.to_datetime(df["Tentative Arrival Date of PM"])
    today = datetime.today().date()
    df["Earliest Available Date"] = df[["RM Date", "PM Date"]].max(axis=1).dt.date
    df["Earliest Available Date"] = df["Earliest Available Date"].apply(lambda x: x if x > today else today)

    # ✅ Create batches
    batches, total_demand, batch_counter = [], 0, 0

    for _, row in df.iterrows():
        demand, batch_size, speed = row["Demand Quantity"], row["Batch Size"], row["Speed"]
        product, available_date = row["Product name"], row["Earliest Available Date"]

        num_batches = math.ceil(demand / batch_size)
        total_demand += demand

        for i in range(num_batches):
            actual_batch_size = batch_size if i < num_batches - 1 else demand - batch_size * (num_batches - 1)
            duration = actual_batch_size / speed
            batches.append({
                "Batch ID": batch_counter,
                "Product": product,
                "Batch Size": int(actual_batch_size),
                "Speed": speed,
                "Duration": duration,
                "Available Date": available_date
            })
            batch_counter += 1

    # ✅ Remove oversized batches
    batches = [b for b in batches if b["Duration"] + CHANGEOVER <= MAX_TIME]
    batches.sort(key=lambda b: b["Duration"], reverse=True)

    START_MIN = 5 * 60 + 30
    schedule = []
    unscheduled = batches.copy()
    schedule_date = today + timedelta(days=1)

    def min_to_time(minutes):
        h, m = int(minutes // 60), int(minutes % 60)
        return f"{h:02}:{m:02}"

    while unscheduled:
        current_time, time_used, day_plan, used_today = START_MIN, 0, [], []
        todays_batches = [b for b in unscheduled if b["Available Date"] <= schedule_date]

        for batch in todays_batches:
            total_time = CHANGEOVER + batch["Duration"]
            if time_used + total_time <= MAX_TIME:
                day_plan.append({
                    "Date": schedule_date.strftime("%Y-%m-%d"),
                    "Stage": "Changeover",
                    "Product": "",
                    "Start": min_to_time(current_time),
                    "End": min_to_time(current_time + CHANGEOVER),
                    "Units Produced": 0
                })
                current_time += CHANGEOVER
                time_used += CHANGEOVER

                end_time = current_time + batch["Duration"]
                units = round(batch["Duration"] * batch["Speed"])
                day_plan.append({
                    "Date": schedule_date.strftime("%Y-%m-%d"),
                    "Stage": "Produce",
                    "Product": batch["Product"],
                    "Start": min_to_time(current_time),
                    "End": min_to_time(end_time),
                    "Units Produced": units
                })
                current_time = end_time
                time_used += batch["Duration"]
                used_today.append(batch)

        if not used_today:
            schedule_date += timedelta(days=1)
            continue

        used_ids = {b["Batch ID"] for b in used_today}
        unscheduled = [b for b in unscheduled if b["Batch ID"] not in used_ids]
        schedule.extend(day_plan)
        schedule_date += timedelta(days=1)

    schedule_df = pd.DataFrame(schedule)
    output = BytesIO()
    schedule_df.to_excel(output, index=False, engine="openpyxl")
    output.seek(0)

    st.success("✅ Ampoule Schedule Ready")
    st.download_button("📥 Download Schedule", output, "Ampoule_Schedule.xlsx")