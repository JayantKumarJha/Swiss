# -*- coding: utf-8 -*-
"""1_Production_Scheduler.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_3XvDnlfdfkTv9S_2V7kZCvvMS9pcWai
"""

import streamlit as st
import pandas as pd
import math
from datetime import datetime, timedelta
from io import BytesIO

st.set_page_config(page_title="Production Scheduler", layout="wide")
st.title("üì¶ SWISS Production Scheduler")

uploaded_file = st.file_uploader("Upload Excel File", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)

    st.sidebar.title("‚öôÔ∏è Speed Override by Pack Size (ml)")
    st.sidebar.markdown("Enter speed (in bottles/min) for each pack size:")

    unique_pack_sizes = sorted(df["Pack Size(ml)"].dropna().unique())
    speed_override = {}

    for size in unique_pack_sizes:
        default_speed = {1: 200, 2: 200, 3: 170, 5: 170, 10: 115}.get(size, 150)
        speed_override[size] = st.sidebar.number_input(
            f"Speed for {int(size)} ml", min_value=1, max_value=1000, value=default_speed
        )

    try:
        df["Speed"] = df["Pack Size(ml)"].map(speed_override)
        df["RM Date"] = pd.to_datetime(df["Tentative Arrival Date of RM"])
        df["PM Date"] = pd.to_datetime(df["Tentative Arrival Date of PM"])
        today = datetime.today().date()

        df["Earliest Available Date"] = df[["RM Date", "PM Date"]].max(axis=1).dt.date
        df["Earliest Available Date"] = df["Earliest Available Date"].apply(
            lambda x: x if x > today else today
        )

        batches = []
        batch_counter = 0
        total_demand = 0

        for _, row in df.iterrows():
            demand = row["Demand Quantity"]
            batch_size = row["Batch Size"]
            speed = row["Speed"]
            product = row["Product name"]
            pack_size = row["Pack Size(ml)"]
            available_date = row["Earliest Available Date"]

            num_batches = math.ceil(demand / batch_size)
            total_demand += demand

            for i in range(num_batches):
                actual_batch_size = batch_size if i < num_batches - 1 else demand - batch_size * (num_batches - 1)
                duration = actual_batch_size / speed
                batches.append({
                    "Batch ID": batch_counter,
                    "Product": product,
                    "Batch Size": int(actual_batch_size),
                    "Speed": speed,
                    "Duration": duration,
                    "Pack Size(ml)": pack_size,
                    "Available Date": available_date
                })
                batch_counter += 1

        MAX_TIME = 1140  # 19 hours
        CHANGEOVER = 180
        fit_batches = []
        too_big_batches = []

        for b in batches:
            if b["Duration"] + CHANGEOVER > MAX_TIME:
                too_big_batches.append(b)
            else:
                fit_batches.append(b)

        if too_big_batches:
            st.warning("‚ö†Ô∏è Some batches were too big to fit and skipped:")
            for b in too_big_batches:
                st.text(f"‚ùå {b['Product']} ‚Äî {b['Duration']:.2f} min")

        batches = fit_batches
        batches.sort(key=lambda b: b["Duration"], reverse=True)

        START_MIN = 5 * 60 + 30
        schedule = []
        unscheduled = batches.copy()
        schedule_date = today + timedelta(days=1)

        def min_to_time(minutes):
            h = int(minutes // 60)
            m = int(minutes % 60)
            return f"{h:02}:{m:02}"

        while unscheduled:
            current_time = START_MIN
            time_used = 0
            day_plan = []
            used_today = []

            todays_batches = [b for b in unscheduled if b["Available Date"] <= schedule_date]

            for batch in todays_batches:
                total_time = CHANGEOVER + batch["Duration"]
                if time_used + total_time <= MAX_TIME:
                    day_plan.append({
                        "Date": schedule_date.strftime("%Y-%m-%d"),
                        "Stage": "Changeover",
                        "Product": "",
                        "Start": min_to_time(current_time),
                        "End": min_to_time(current_time + CHANGEOVER),
                        "Units Produced": 0
                    })
                    current_time += CHANGEOVER
                    time_used += CHANGEOVER

                    end_time = current_time + batch["Duration"]
                    units = round(batch["Duration"] * batch["Speed"])
                    day_plan.append({
                        "Date": schedule_date.strftime("%Y-%m-%d"),
                        "Stage": "Produce",
                        "Product": batch["Product"],
                        "Start": min_to_time(current_time),
                        "End": min_to_time(end_time),
                        "Units Produced": units
                    })
                    current_time = end_time
                    time_used += batch["Duration"]
                    used_today.append(batch)

            if not used_today:
                schedule_date += timedelta(days=1)
                continue

            used_ids = {b["Batch ID"] for b in used_today}
            unscheduled = [b for b in unscheduled if b["Batch ID"] not in used_ids]
            schedule.extend(day_plan)
            schedule_date += timedelta(days=1)

        schedule_df = pd.DataFrame(schedule)
        output = BytesIO()
        schedule_df.to_excel(output, index=False, engine='openpyxl')
        output.seek(0)

        st.success("‚úÖ Schedule Ready")
        st.download_button("üì• Download Schedule", output, file_name="Schedule.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        st.markdown(f"üì¶ **Total Demand:** `{total_demand:,}` units")
        st.markdown(f"‚úÖ **Scheduled Units:** `{int(schedule_df['Units Produced'].sum()):,}`")
        st.markdown(f"üìÖ **Days Used:** `{schedule_df['Date'].nunique()}`")

    except Exception as e:
        st.error(f"‚ùå Error: {str(e)}")